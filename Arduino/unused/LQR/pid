// 모터 제어 핀 (MD10C 방식)
const int MOTOR_DIR_PIN = 12;    // 방향 제어
const int MOTOR_PWM_PIN = 11;    // PWM 출력

// 인터럽트 핀 (A상, B상 엔코더용)
const int encoderPinA = 2;       // 인터럽트 가능
const int encoderPinB = 7;       // 일반 핀

// 엔코더 관련 변수
volatile long encoderCount = 0;

// 아날로그 각도 센서 변수
float ADCvalue = 0;
float currentAngle = 0;
const float ADCmin = 104.0;
const float ADCmax = 919.0;
const float ANGLE_OFFSET = 110.7 - 26.1;

// PID 제어 변수
double targetAngle = 0.0;
double angleError = 0.0;
double controlSignal = 0.0;
double previousError = 0.0;
double integralTerm = 0.0;
double Kp = 23.0, Ki = 0.75, Kd = 25;

// 타이머
unsigned long lastControlTime = 0;
const unsigned long controlInterval = 10;

// 실행 상태
bool isRunning = true;

// ✅ 거리 계산 관련 상수 (단위: m 기준)
const float wheelRadiusCM = 4.0;
const float wheelCircumferenceCM = 2 * PI * wheelRadiusCM;
const int encoderPPR = 38;
const int gearRatio = 14;
const int countsPerRevolution = encoderPPR * gearRatio * 4;

// ✅ 거리 보정 계수 (10cm → 9.21cm 보정용)
const float distanceCorrectionFactor = 10.0 / 9.21;  // ≈ 1.0856

// ✅ 거리 계산 함수 (단위: m)
float getCartDistanceM() {
  float rotations = encoderCount / (float)countsPerRevolution;
  return (rotations * wheelCircumferenceCM * distanceCorrectionFactor) / 100.0;
}

// ADC 평균 필터 함수
float readFilteredADC(int pin, int sampleCount = 100) {
  long total = 0;
  for (int i = 0; i < sampleCount; i++) {
    total += analogRead(pin);
    delayMicroseconds(5);
  }
  return total / (float)sampleCount;
}

void setup() {
  Serial.begin(115200);

  pinMode(MOTOR_DIR_PIN, OUTPUT);
  pinMode(MOTOR_PWM_PIN, OUTPUT);

  pinMode(encoderPinA, INPUT_PULLUP);
  pinMode(encoderPinB, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(encoderPinA), updateEncoder, CHANGE);

  Serial.println("Press 'r' to start/stop the control loop.");
}

void loop() {
  if (Serial.available() > 0) {
    char input = Serial.read();
    if (input == 'r' || input == 'R') {
      isRunning = !isRunning;
      if (!isRunning) {
        stopMotor();
        Serial.println("System STOPPED.");
      } else {
        Serial.println("System RUNNING.");
      }
    }
  }

  if (isRunning && millis() - lastControlTime >= controlInterval) {
    lastControlTime += controlInterval;

    // 1. ADC → 각도
    ADCvalue = readFilteredADC(A0, 100);
    currentAngle = (ADCvalue - ADCmin) * 360.0 / (ADCmax - ADCmin);
    currentAngle = constrain(currentAngle, 0.0, 360.0);

    // 2. 오프셋 보정
    currentAngle += ANGLE_OFFSET;
    if (currentAngle < 0) currentAngle += 360.0;
    if (currentAngle >= 360.0) currentAngle -= 360.0;

    // 3. -180 ~ +180 변환
    float relativeAngle = currentAngle;
    if (relativeAngle > 180.0) relativeAngle -= 360.0;

    // 4. 목표 각도
    targetAngle = 0.0;
    angleError = relativeAngle - targetAngle;

    // 5. PID 제어
    if (abs(angleError) > 30.0 || abs(angleError) < 0.000001) {
      stopMotor();
      integralTerm = 0;
      previousError = 0;
    } else {
      integralTerm += angleError;
      integralTerm = constrain(integralTerm, -120, 120);
      double derivativeTerm = (angleError - previousError);
      previousError = angleError;

      controlSignal = (Kp * angleError) + (Ki * integralTerm) + (Kd * derivativeTerm);
      int pwmValue = constrain(abs(controlSignal), 0, 255);
      moveMotor(pwmValue, controlSignal > 0);
    }

    // 6. 디버깅 출력 (200ms 간격)
    static unsigned long lastDebugTime = 0;
    if (millis() - lastDebugTime >= 200) {
      lastDebugTime = millis();
      Serial.print("ADC: "); Serial.print(ADCvalue, 2);
      Serial.print(" | Angle: "); Serial.print(currentAngle, 4);
      Serial.print(" | Error: "); Serial.print(angleError, 4);
      Serial.print(" | PWM: "); Serial.print(abs(controlSignal));
      Serial.print(" | Encoder Count: "); Serial.print(encoderCount);
      Serial.print(" | Distance: "); Serial.print(getCartDistanceM(), 3);
      Serial.println(" m");
    }
  }
}

// 인터럽트 핸들러
void updateEncoder() {
  bool A = digitalRead(encoderPinA);
  bool B = digitalRead(encoderPinB);
  if (A == B) {
    encoderCount++;
  } else {
    encoderCount--;
  }
}

// 모터 제어 함수
void moveMotor(int pwm, bool forward) {
  digitalWrite(MOTOR_DIR_PIN, forward ? HIGH : LOW);
  analogWrite(MOTOR_PWM_PIN, pwm);
}

// 모터 정지 함수
void stopMotor() {
  analogWrite(MOTOR_PWM_PIN, 0);
}
